[toc]
# 可选链运算符

- 可选链运算符是一种先检查属性是否存在，再尝试访问该属性的运算符，其符号为 `?.`
- 如果运算符左侧的操作数 `?.` 计算为 undefined 或 null，则表达式求值为 undefined 。否则，正常触发目标属性访问、方法或函数调用。
- 可选链运算符处于 stage3 阶段，使用 @babel/plugin-proposal-optional-chaining 插件可以提前使用，TS 3.7版本正式支持使用，以前的版本会报错

```ts
a?.b;
// 相当于 a == null ? undefined : a.b;
// 如果 a 是 null/undefined，那么返回 undefined，否则返回 a.b 的值.

a?.[x];
// 相当于 a == null ? undefined : a[x];
// 如果 a 是 null/undefined，那么返回 undefined，否则返回 a[x] 的值

a?.b();
// 相当于a == null ? undefined : a.b();
// 如果 a 是 null/undefined，那么返回 undefined
// 如果 a.b 不是函数的话，会抛类型错误异常，否则计算 a.b() 的结果


```

# 泛型的使用 Partial、Pick、Required、Exclude

首先我们需要理解这两个关键字 `keyof`、`in`; `keyof` 可以用来取得一个对象接口的所有 `key` 值；

```ts
interface Foo {
	name: string;
	age: number;
}

// T -> 'name' | 'age';
type T = keyof Foo;
// keyof 会产生联合类型


type Keys = 'a' | 'b';
type Obj = {
	[p in Keys]: any
}

// Obj -> { a: any, b: any}
// in 则可以遍历枚举类型

```

### Partial adj. 局部的；偏爱的；不公平的

```ts 
// 源码
type Partial<T> = {
	[p in keyof T]?: T[p]
}

// 使用

interface Foo {
	name: string;
	age: number;
}

type B = Partial<Foo>

// b 只能够定义name和age属性， 且都是可选的；
let b: B = {
	name: 'hzg'
	age: 19
}

```

### Required 必选的

```ts
// 源码
type Required<T> = {
	// [p in keyof T]: T[p]
	[p in keyof T] -?: T[p]
}
```

我们发现一个有意思的用法 `-?`, 这里很好理解就是将可选项代表的 ? 去掉, 从而让这个类型变成必选项. 与之对应的还有个 `+?` , 这个含义自然与 `-?` 之前相反, 它是用来把属性变成可选项的.


### Pick （挑选）

> 从 T 中取出 一系列 K 的属性

```ts
type Pick<T, K extends keyof T> = {
	[P in K]: T[P]
}


interface User {
	name: string;
	age: number;
}

// PickUser 类型 是从Pick接口中 选出来的； K是对象想选的是哪个属性

type PickUser = <Pick, 'age'>
let u: PickUser = {
	age: 90
}

type PickUser1 = <Pick, 'age' | 'name'>

let u1: PickUser1 = {
	age: 9,
	name: 'hh'
}

```

### Exclude （排除）


 - 在 ts 2.8 中引入了一个条件类型, ```T extends U ? X : Y```

 - 以上语句的意思就是 如果 T 是 U 的子类型的话，那么就会返回 X，否则返回 Y

 ```ts
type Exclude<T, U> = T extends U ? never : T;

const str: Exclude<'a' | '1' | '2', 'a' | 'y' | 'z'> = '1'; // str 可为 '1' 或 '2'

// 可以很好的理解，Exclude 就是将前面类型的与后面类型对比，过滤出前面独有的属性
 ```


### Omit(剩余)

- 通过使用 Pick 和 Exclude 来组合一个新的类型 Omit

```ts
type Pick<T, K extends keyof T> = {
	[P in K]: T[P]
}

type Exclude<T, U> = T extends U ? never : T


type Omit<T, K> = Pick<T, Exclude<keyof T, K>>;


interface User {
	id: number;
	name: string;
	age: number;
}

// 相当于 type OmitUser = {age: number, name: string}
type OmitUser = Omit<User, 'id'>

```

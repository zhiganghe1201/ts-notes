# 扩展类型

> 扩展类型： 类型别名、枚举、接口、类

# 枚举

枚举通常用于约束某个变量的取值范围。

字面量和联合类型配合使用， 也可以达到同样的目标；

### 字面量类型的问题

- 在类型约束位置， 会产生重复代码。 可以使用类型别名解决该问题。
- 逻辑含义和真实的值产生了混淆， 会导致当修改真实的值的时候，产生大量的修改。
- 字面量类型不会进入到编译结果；

如何定义一个枚举

```js
	enum 枚举名 {
		枚举字段1 = 值1,
		枚举字段2 = 值2
	}
```
``` js
	enum Gender {
		male = '男',
		female = '女'
	}

	let gender: Gender;
	gender = Gender.male;
```

枚举会参与编译， 会出现在编译结果中出现；编译结果中表现是一个对象； 字面量方式不会出现在编译结果中；

枚举的规则：

- 枚举的值可以是字符串和数字
- 数字枚举的值会自动自增；
- 被数字枚举约束的变量，可以直接赋值为数字；
- 4数字枚举的编译结果和字符串枚举有差异；

```js
 enmu Level {
	 level1 = 1,
	 level2,
	 level3
 }
```


```js
enmu Level {
	 level1 = 1,
	 level2,
	 level3
 }

// 数字枚举的编译结果 和 字符串编译结果的差异
{
	level1: 0,
	level2: 1,
	level3: 2,
	0: 'level1',
	1: 'level2',
	2: 'level3'
}

```

最佳实践

- 尽量不要在一个枚举中即出现字符串字段又出现数字字段；
- 使用枚举时，尽量使用枚举字段的名称， 而不是使用真实的值；

### 扩展的知识： 位枚举（枚举的位运算）

只针对数字枚举

位运算： 两个数字换算成二进制后进行的运算；



# 模块化

> 前端模块化的标准： ES6、commonjs、amd、umd、system、esnext

### TS中如何书写模块化语句

> TS 中导入和导出模块， `统一使用ES6的模块化` 避免出错; 
 
普通导出 可以智能提示， 快速修复； 默认导出（ `export default`)， 不能智能提示； 因为可以修改导出的名字；

不要加后缀名；编译结果中没有`.ts`文件

### 编译结果中的模块化

dist 文件夹   编译命令 tsc; `tsc --watch` 监听文件变化，文件变化后会重新编译；

去掉编译结果中的注释 tsconfig.json中 加`"removeComments: true"`

|		配置名称		 |		含义		|
| :-------------------: | :---------------:|
| module				| 设置编译结果中使用的模块化标准 |
| moduleResolution		| 设置解析模块的模式 |
| noImplicitUseStrict	| 编译结果中不包括"use strict" |
| removeComments 		| 编译结果中移除注释 |
| noEmitOnError			| 错误时不生成编译结果 |
| esModuleInterop 		| 启用es模块化交互非es模块导出 |

TS中的模块化在编译结果中：
- 如果编译结果的模块化标准是ES6: 没有区别；
- 如果编译结果的模块化标准是commonJs： 导出的声明会变成exports的属性。 默认的导出会变成exports的default属性；导入时会把对象拿到； 通过对象属性的方式执行；

### 解决默认导入的错误

```js

import fs from 'fs';// 会报错； 因为fs模块采用的是 module.exports = {}; 方式导出的； 不是采用es6默认导出方式；

// 解决方式

import * as fs from 'fs';
import { readFileSync } from 'fs';

// 上面两种方式可以解决默认导入的错误；

// 或者编译选项中增加配置； 直接导入就不会出错
// esmoduleInterop : true 

```


# 如何在TS中书写commonjs模块化代码

不太建议；建议使用es6模块化   

```js
// 老式方式 没有类型推导  module.export = xxx;  const xxx = require('xxx');
// 导出  export = XXX
export = {

}

// 导入 import xxx = require('xxx')

import myModule = require('./myModule')


```


# 模块解析

模块解析： 应该从什么位置寻找模块
TS中， 有两种模块解析策略

- classic: 经典
- node: node解析策略（唯一变化， 将js替换为ts);

> 增加模块解析策略配置： `moduleResolution: 'node'` 强行设置为node解析策略


# 接口和类型兼容性

接口： `interface`   最大区别在于约束类   和 类型别名的却别
### 扩展类型 - 接口
自己定义的类型    类型别名、枚举、接口、类

TypeScript的接口： 用于约束类、对象、函数的契约（标准）

契约（标准）的形式
- 如Api文档， 弱标准
- 代码约束，强标准

> 接口和类型别名一样， 不会出现在编译结果中的；


1. 接口约束对象


```js
// 接口来约束对象
interface User {
	name: string,
	age: number
}

let u:User = {
	name: 'hzg',
	age: 18
}

// 类型别名
 type User = {
	name: string,
	age: number
 }

let uu: User;

// 从上面看类型别名和接口来约束对象没啥区别

```

**接口可以继承** 

可以通过接口之间的继承， 实现多种接口的结合

使用类型别名可以实现类似的组合效果， 需要通过 ``` & ```， 叫做交叉类型

它们的区别：
- 子接口不能覆盖父接口的成员；
- 交叉类型会把相同成员进行交叉；

**readonly**

只读修饰符：不能重新复制； 不在编译结果中；（不参与编译）


```ts
interface User{
	readonly id: number,
	user: string, 
}

let u = {
	id: 2323,
	user: 'hzg'
}

let arr: readlyonly numbe[] = [1,2,3,4,5]; // 这样的数组所有的改变原数组的方法都不可用了， 

const arr1 = ReadonlyArray<number> = [1,2,3,4,5];

type Us = {
	readyonly id: number,
	readonly name: readonly number[] // name 数组不能改变， 里面的值 初次赋值后也不能重新赋值；
}


```

# 类型兼容性

B -> A , 如果能完成赋值， 则B和A类型兼容；

鸭子辨型法(子结构辨型法)； 满足特征就行；如：是否是🦆， 1、会嘎嘎叫 2、会游泳
是不是一只鸭子， 拥有鸭子的特征就行

目标类型需要某一些特征， 赋值的类型只要能满足该特征即可

- 基本类型： 完全匹配

- 对象类型： 鸭子辨型法（满足特征就行）

```ts

interface Duck {
	sound: '嘎嘎嘎'
	swin(): void
}


let person = {
	name: '伪装成鸭子的人',
	age: 11,
	sound: '嘎嘎嘎' as '嘎嘎嘎',

}

let duck: Duck;


```
类型断言

对象：当直接使用对象字面量赋值时， 将采用`更加严格的`判断

- 函数类型

一切无比的自然： 
**函数参数**: 传递给目标函数的参数可以少， 但不可以多
**返回值**：要求返回必须返回， 且类型相同； 不要求返回，你随意
[toc]

# 基础类型

#### void

声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null;
通常用着函数没有返回值时使用

#### null、undefined

- 默认情况下null和undefined是所有类型的子类型; 可以赋值给任意类型；
- 当你指定了--strictNullChecks标记，null和undefined只能赋值给`void`和它们各自

#### never

通常用于约束函数的返回值，表示该函数永远不可能结束；
表示一个不包含值的类型， 即表示永远不存在的值。

- 拥有 void 返回值类型的函数能正常运行。拥有 never 返回值类型的函数无法正常返回，无法终止，或会抛出异常。

# 扩展类型

> 扩展类型： 类型别名、枚举、接口、类

# 枚举

枚举通常用于约束某个变量的取值范围。

字面量和联合类型配合使用， 也可以达到同样的目标；

```ts
 let a: '1' | '2' = '3';
```

### 字面量类型的问题

- 在类型约束位置， 会产生重复代码。 可以使用类型别名解决该问题。
- 逻辑含义和真实的值产生了混淆， 会导致当修改真实的值的时候，产生大量的修改。
- 字面量类型不会进入到编译结果；

如何定义一个枚举

```ts
	enum 枚举名 {
		枚举字段1 = 值1,
		枚举字段2 = 值2
	}
```
``` ts
	enum Gender {
		male = '男',
		female = '女'
	}

	let gender: Gender;
	gender = Gender.male;
```

枚举会参与编译， 会出现在编译结果中出现；编译结果中表现是一个对象； 字面量方式不会出现在编译结果中；

枚举的规则：

- 枚举的值可以是字符串和数字
- 数字枚举的值会自动自增；
- 被数字枚举约束的变量，可以直接赋值为数字；
- 数字枚举的编译结果和字符串枚举有差异；

```js
 enmu Level {
	 level1 = 1,
	 level2,
	 level3
 }
```


```ts
enum Level {
	 level1 = 1,
	 level2,
	 level3
 }

// 数字枚举的编译结果 和 字符串编译结果的差异
//  提供的一个便利是你可以由枚举的值得到它的名字  Level[2] === 'level2'

{
	level1: 1,
	level2: 2,
	level3: 3,
	'1': 'level1',
	'2': 'level2',
	'3': 'level3'
}

// 字符串枚举编译结果
enum Level2 {
	a = '1',
	b = '2'
}

{
	a: '1',
	b: '2'
}

```

**最佳实践**

- 尽量不要在一个枚举中即出现`字符串字段`又出现`数字字段`；
- 使用枚举时，尽量使用枚举字段的名称， 而不是使用真实的值；

### 扩展的知识： 位枚举（枚举的位运算）

只针对数字枚举

位运算： 两个数字换算成二进制后进行的运算；

```ts
// 位枚举  两个数字换算成二进制后进行的运算；
enum Permission {
	Read = 1, // 2^0  二进制 0001  根据每个位置上的标识来判断是否有对应的权限； 1代表有权限；
	Write = 2, // 2^1	0010
	Create = 4, // 2^2	0100
	Delete = 8 // 2^3	1000
}

// 1: 如何组合权限
// 使用或运算 
// 0001
// | 或运算  一个为真就为真，全假为假
// 0010
// ----
// 0011
let p: Permission = Permission.Read | Permission.Write;
p = p | Permission.Delete; // 10119

// 2: 如何判断是否拥有某个权限；
/**
 * 
 * @param targe 需要判断的目标
 * @param per 对应的真实权限
 */
// 0011
// & 且运算 全真为真， 否者为假
// 0001
// ----
// 0001
function hasPermission(target:Permission, per:Permission) {
	return (target & per) === per; 
}

// 判断变量p是否拥有可读权限
console.log(hasPermission(p, Permission.Create));

// 3:如何删除某个权限  (删除写权限)
// 0011
// 异或   相同取0，不同取1
// 0010
// ----
// 0001

p = p ^ Permission.Write;

```

# 模块化

> 前端模块化的标准： ES6、commonjs、amd、umd、system、esnext

### TS中如何书写模块化语句

> TS 中导入和导出模块， `统一使用ES6的模块化` 避免出错; 
 
普通导出 可以智能提示， 快速修复； 默认导出（ `export default`)， 不能智能提示； 因为可以修改导出的名字；

不要加后缀名；编译结果中没有`.ts`文件

### 编译结果中的模块化

dist 文件夹   编译命令 tsc; `tsc --watch`、`ts -w` 监听文件变化，文件变化后会重新编译；

去掉编译结果中的注释 tsconfig.json中 加`"removeComments: true"`

|		配置名称		 |		含义		|		推荐值		|
| :-------------------: | :---------------:| :-------------: |
| module				| 设置编译结果中使用的模块化标准 | esnext  |
| moduleResolution		| 设置解析模块的模式 |		node 		|
| noImplicitUseStrict	| 编译结果中不包括"use strict" |  true  |
| removeComments 		| 编译结果中移除注释 |		toUpperCase  |
| noEmitOnError			| 错误时不生成编译结果 |	true 		|
| esModuleInterop 		| 启用es模块化交互非es模块导出 | true 	|

TS中的模块化在编译结果中：
- 如果编译结果的模块化标准是ES6: 没有区别；
- 如果编译结果的模块化标准是commonJs： 导出的声明会变成exports的属性。 默认的导出会变成exports的default属性；导入时会把对象拿到； 通过对象属性的方式执行；

### 解决默认导入的错误

```ts

import fs from 'fs';// 会报错； 因为fs模块采用的是 module.exports = {}; 方式导出的； 不是采用es6默认导出方式；

// 解决方式

import * as fs from 'fs';
import { readFileSync } from 'fs';

// 上面两种方式可以解决默认导入的错误；

// 或者编译选项中增加配置； 直接导入就不会出错
// esmoduleInterop : true 

```


# 如何在TS中书写commonjs模块化代码

不太建议；建议使用es6模块化   

```js
// 老式方式 没有类型推导  module.export = xxx;  const xxx = require('xxx');
// 导出  export = XXX
export = {

}

// 导入 import xxx = require('xxx')

import myModule = require('./myModule')
```


# 模块解析

模块解析： 应该从什么位置寻找模块
TS中， 有两种模块解析策略

- classic: 经典
- node: node解析策略（唯一变化， 将js替换为ts);

> 增加模块解析策略配置： `moduleResolution: 'node'` 强行设置为node解析策略


# 接口和类型兼容性

接口： `interface` 最大区别在于约束类 在 类型别名的区别

### 扩展类型 - 接口
自己定义的类型    类型别名、枚举、接口、类

TypeScript的接口： 用于约束类、对象、函数的契约（标准）

契约（标准）的形式
- 文档：如Api文档， 弱标准
- 代码约束，强标准

> 接口和类型别名一样， 不会出现在编译结果中的；

1. 接口约束对象

```ts
// 接口来约束对象
interface User {
	name: string,
	age: number
}

let u:User = {
	name: 'hzg',
	age: 18
}

// 类型别名
 type User = {
	name: string,
	age: number
 }

let uu: User;

// 从上面看类型别名和接口来约束对象没啥区别

```

**接口可以继承** 

可以通过接口之间的继承， 实现多种接口的结合

接口和类型别名的最大区别： 接口可以被类实现 `implements`， 而类型别名不可以

使用类型别名可以实现类似的组合效果， 需要通过 ``` & ```， 叫做交叉类型

它们的区别：
- 子接口不能覆盖父接口的成员；
- 交叉类型会把相同成员进行交叉；

**readonly**

只读修饰符：不能重新复制； 不在编译结果中；（不参与编译）

```ts
interface User{
	readonly id: number,
	user: string, 
}

let u = {
	id: 2323,
	user: 'hzg'
}

let arr: readlyonly numbe[] = [1,2,3,4,5]; // 这样的数组所有的改变原数组的方法都不可用了， 如push、pop

const arr1 = ReadonlyArray<number> = [1,2,3,4,5];

type Us = {
	readonly id: number,
	readonly name: readonly number[] // name 数组不能改变， 里面的值 初次赋值后也不能重新赋值；
}


```

### 接口继承类

```ts

class A {
	a1: string = '',

}
class B {
	b1: number = 1
}

interface C extends A, B {}


```

# 索引器

`对象[值]` 使用成员表达式

在Ts中， 默认情况下对索引器（成员表达式）不做严格的类型检查；

```ts
	u['xxx'] // []是运行后才得到的表达式， 所以不做类型检查
```
使用配置`noImplicitAny`开启`隐式any`检查。 强约束

隐式any： TS根据实际情况推导出的any情况  

```ts
// n 会被推导出是any类型
 function t(n){}


 class {
	 [prop: string]: any;

	 constructor (
		 public name: string,
		 public age: string
	 )
 }
```

在索引器中， 键的类型可以是字符串或数字


在类中， 索引器书写的位置应该是在所有成员之前

TS中索引器的作用

- 在严格的检查下， 可以实现为类动态增加成员
- 可以实现动态的操作类成员

在`JS`中， 所有的成员名本质上， 都是字符串， 如果使用数字作为成员名， 会自动转换为字符串

在TS中， 如果某个类中使用了两种类型的索引器， 要求两种索引器的值类型必须匹配

```ts
const arr3: number[] = [];
arr3[0] = 1;
arr3['0'] = 5;

console.log(arr3[0]);

// 在JS中， 所有的成员名本质上， 都是字符串， 如果使用数字作为成员名， 会自动转换为字符串

class A {
	[prop: number]: string
}

const a = new A();

a[1] = 9; // 会报错 因为成员名会被转换为string类型； 和索引器number类型冲突
```


# 类型兼容性

B -> A , 如果能完成赋值， 则B和A类型兼容；

鸭子辨型法(子结构辨型法)； 满足特征就行；如：是否是🦆， 1、会嘎嘎叫 2、会游泳
是不是一只鸭子， 拥有鸭子的特征就行

目标类型需要某一些特征， 赋值的类型只要能满足该特征即可

- 基本类型： 完全匹配

- 对象类型： 鸭子辨型法（满足特征就行）

```ts

interface Duck {
	sound: '嘎嘎嘎'
	swin(): void
}


let person = {
	name: '伪装成鸭子的人',
	age: 11,
	sound: '嘎嘎嘎' as '嘎嘎嘎',
	swin() {
		console.log('gagga')
	}

}
// 声明一个变量， 约束为一个鸭子但是可以把人赋值给他； 
let duck: Duck = person;


```
类型断言

对象：当直接使用对象字面量赋值时， 将采用`更加严格的`判断

- 函数类型

一切无比的自然： 
**函数参数**: 传递给目标函数的参数可以少， 但不可以多
**返回值**：要求返回必须返回， 且类型相同； 不要求返回，你随意


# TS中的类

面向对象思想 很难理解   小有成就三年

基础部分， 学习类的时候， 仅讨论新增的语法部分。

- 类的继承： 父类又叫做基类、超类， 子类又叫做派生类

**属性**

使用属性列表来描述类中属性
```ts
class User {
	// 用属性列表来表明类有哪些属性
	readonly id: number = 1;
	name: string;
	age: number;
	// gender: 'male' | 'female' = 'male' // 1 属性初始化 默认值   在属性列表中
	pid ?: string  // 属性可选  string | undefined  可选的就不必为必须初始化

	constructor(name: strinng, age: number, gender: 'male' | 'female' = 'male') {
		this.name = name;
		this.age= age;
		this.gender = gender;  // 2 初始化默认值在构造函数中 属性默认值
	}
}

const obj = {};
obj.a = 'aaa';
// 在Ts中上面的写法会报错； 一个对象在创建的时候，它的属性应该就要创建下来； 后面的属性不能随意的增加；
```


**属性的初始化检查** 没有赋值时 值为 `undefined`

`strictPropertyInitializtion: true`  更加严格的属性初始化检查； 除可选属性外声明时必须初始化

属性的初始化位置：
1. 构造函数中；
2. 属性的默认值

- 属性可以修饰为可选的； 可选的就不必为必须初始化 `?:`
- 属性可以修饰为只读的 `readonly`  `只读属性必须在声明时或构造函数里被初始化。不然实例时值为undefined, 不能再次赋值了`

- 使用访问修饰符 | 访问限定符
	- 访问修饰符可以控制类中的某个成员(方法、属性）的访问权限
	- public: 默认的访问修饰符，公开的。所有的代码都可以使用； 不写修饰符默认都是`public`
	- private: 私有的， 只能在类的里面使用
	- protected: 受保护的， `能在类的里面和子类中使用`

	```ts
	// 构造函数也可以被标记成 protected。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。
	class Person {
		protected name: string;
		protected constructor(theName: string) { this.name = theName; }
	}

	// Employee 能够继承 Person
	class Employee extends Person {
		private department: string;

		constructor(name: string, department: string) {
			super(name); // 调用父类的构造函数
			this.department = department;
		}

		public getElevatorPitch() {
			return `Hello, my name is ${this.name} and I work in ${this.department}.`;
		}
	}

	let howard = new Employee("Howard", "Sales");
	let john = new Person("John"); // 错误: 'Person' 的构造函数是被保护的.
	 
	```

#### 属性简写

如果某个属性， 通过构造函数的参数传递， 并且不做任何处理的赋值给该属性。 可以进行简写； 参数前添加访问修饰符；  不需要写属性列表和属性赋值

```ts 
class User {
	// name: string  
	constructor(public name: string, public age: number) {
		// this.name = name;
		// this.age = age;  属性简写 前面加修饰符 可省属性列表和属性赋值
	}
}
```



#### 访问器  setters getters

作用： 用于控制属性的读取和赋值

```ts

class User {
	readonly id: number;
	gender : 'male' | 'female' = 'male';
	pid?: string;

	constructor(public name: string, private _age: number) {
		this.id = Math.random();
	}

	get age() {
		return this._age;
		// 
	}

	set age(val: number) {
		this._age = val;
	}

}

// 死循环不一定导致内存泄漏  无限递归一定导致内存泄漏
```
- 只带有 get不带有 set的存取器自动被推断为 `readonly`。

### 单根性和传递性

单根性： 每个类最多只能拥有一个父类

传递性： 如果A是B的父类， 并且B是C的父类， 则可以认为A也是C的父类；


# 抽象类和抽象方法

### 抽象类

有时， 某个类只表示一个抽象概念， `主要用于提取子类共有的成员`， 而不能直接创建它的对象， 该类可以作为抽象类；`chess.ts`

给类前面加上```abstruct```,表示该类是一个抽象类， 不可以创建一个抽象类的对象

### 抽象成员

父类中， 可能知道有些成员是必须存在的， 但不知道该成员的值或实现是什么， 因此， 需要一个强约束， 让继承该类的子类， 必须要实现该成员。

`抽象类中`，可以有抽象成员， 这些抽象成员必须在子类中实现


1. 使用 `abstract` 修饰符修饰的类被称为抽象类；
	抽象类不能实例化对象， 只能被继承；

2. 使用 `abstract` 修饰符修饰的方法或属性被称为抽象方法或抽象属性；
	抽象方法不能有方法体， 子类必须重写抽象类中所有的抽象方法和抽象属性；


3. 抽象类中不一定包含抽象方法， 但包含抽象方法的类一定是抽象类；

###  设计模式 - 模板模式

模板模式： 有些方法， 所有的子类实现的流程完全一致， 只是流程中某个步骤的具体实现不一样， 可以将该方法提取到父类， 在父类中完成整个流程的实现， 遇到实现不一致的方法时， 将该方法做出抽象方法；

### 静态成员

静态成员： 静态属性、静态方法; 指附着在类上的成员（属于某个构造函数的成员）

使用static 修饰的成员， 是静态成员；

实例成员： 对象成员、属于某个类的对象

静态成员： 非实例成员， 属于某个类；

### 静态方法中的this

实例方法中this指向的是 `当前对象`

静态方法中this指向的是 `当前类

### 设计模式 - 单例模式

单例模式： `某些类的对象， 在系统中最多只能有一个`， 为了避免开发者造成随意创建多个类对象的错误， 可以使用单例模式进行强约束；

```ts

class Board {
	 width: number = 500;
	 height: number = 700;

	 init() {
		 console.log('初始化棋盘')
	 }

	// 构造函数私有化 在类外面不可实例化
	 private constructor() {} 

	 private static _board?: Board;

	// 静态方法
	 static createBoard(): Board {
		 if(this._board) {
			 return this._board;
		 }

		 this._board = new Board();
		 return this._board;
	 }


	 static readonly singleBoard: Board = new Board();
 }
```


# 泛型


有时，书写某个函数时， 会丢失一些信息（`多个位置的类型应该保持一致`或有关联的信息）

泛型： 是指`附属于`（附加一个类型）函数、类、接口、类型别名之上的类型；
> 注意： 无法创建泛型枚举和泛型命名空间

泛型相当于一个类型变量，在定义时， 无法预先知道具体的类型， 可以用该变量来替代， `只有调用时， 才能确定他的类型`； 使用泛型会得到更加一致的类型检查；

很多时候， TS会智能的根据传递的参数， 推导出泛型的具体类型；

如果无法完成推导， 并且又没有传递具体的类型， 默认为空对象类型；

泛型可以设置默认值；

## 在函数中使用泛型

在函数名之后写上```<泛型名称>```

```ts
function take<T = number>(arr: T[], n: number): T[] {

}


take<number>([1,2,4,5,6], 3)
```

##  在类型别名、接口、类中使用泛型

直接在名称之后写上 ```<泛型名称>```


## 泛型约束

泛型约束用于限制泛型的取值；


```ts
interface hasNameProperty {
	name: string
}

/**
 * 将某个对象的name属性的每个单词的首字母大写，并将该对象返回；
 */

 // 泛型将来可以是任何类型；
function nameToUppercase<T extends hasNameProperty>(obj: T): T {
	// obj.name  // 没有约束时   将来传的值不是对象， 或者对象没有name属性 就报错

	obj.name = obj.name.split(' ').map(it => it[0].toUpperCase() + it.substr(1)).join(' ');
	return obj
}


const o = {
	name: 'kevin he',
	age: 9,
	gender: 'meal'
};


const newO = nameToUppercase(o);

console.log(newO);
```

### 多泛型

```ts
	// 将两个数组 [1,2,3] + ['a', 'b', 'c'] = [1, 'a', 2, 'b', 3, 'c']
	function mixinArray(T, K)(arr1: T[], arr2: K[]): (T | K)[] {
		if(arr1.length === arr2.length) {
			throw new Error("两个数组的长度不等！")
		}

		const result: (T | K)[] = [];
		for(let i, len = arr1.length; i < len; i ++) {
			result.push(arr1[i]);
			result.push(arr2[i])
		}

		return result;
	}

```


Symbol  符号

迭代器： 表示该数据是可以被 for - of  循环的 ；制造迭代器 必须使用 Symbol iterator


js 错误发生在运行时；   js 是解释性语言； 运行时才知道； 

Ts是一套类型系统， 静态的，不用运行起来  写代码时就可以进行提示；(编译阶段 就进行提醒)


# 深入理解类和接口

### 面向对象概述

#### 为什么要讲面向对象？
1. TS 为前端面向对象开发带来了契机

js语言没有类型检查， 如果使用面向对象的方式开发， 会产生大量的接口， 而大量的接口会导致调用复杂度剧增， 这种复杂度必须通过严格的类型检查来避免错误， 尽管可以使用注释或文档或记忆力， 但他们没有强约束。

TS带来了完整的类型系统， 因此开发复杂程序时， 无论接口数量有多少， 都可以获得完整的类型检查， 并且这种检查是具有强约束力的；

2. 面向对象中有许多非常成熟的模式， 能处理复杂问题；

## 什么是面向对象

面向对象：Oriented（基于） Object（事务）。 简称OO。它提出一切以对象对切入点思考问题；


### 类的继承

 类重写时：子类不能修改父类的成员的类型：

 ### 类型匹配

鸭子辨型法

子类的对象始终可以赋值给父类

```ts
class Tank {

}

class PlayTank extends Tank {

}

let p: Tank = new PlayTank();

// P 只可以使用 和父类共有的属性；


```



# 再谈接口

接口用来约束类、对象、函数， 是一个类型契约；

> 有一个马戏团， 马戏团有很多动物， 包括： 狮子、老虎、猴子、狗， 这些动物都具有共同的特征： 名字、年龄、种类名称， 还包括一个共同的方法： sayHello, 它们各自有各自的技能： 打招呼， 技能是可以训练改变的；

> 马戏团中有以下常见的技能

> - 火圈表演： 单火圈、双火圈
> - 平衡表演： 独木桥、走钢丝
> - 智慧表演： 算术题、跳舞


面向对象领域中的接口的语义： 表达了某个类是否拥有某种能力

某个类具有某种能力， 其实， 就是实现了某种接口

### 类型保护  判断存在后  再执行某些操作


### 在JS中this的指向的几种情况

明确：大部分时候， this的指向取决于函数的调用方式

- 如果直接调用函数（全局调用）， this指向全局对象（浏览器windown对象， node环境global对象）或undefined(启用严格模式)； ``` use()```
- 如果使用`对象.方法`调用， this指向对象本身；```use.xxx()```
- 如果是dom事件的处理函数， this指向事件处理对象  (按钮点击、鼠标移入)

特殊情况：
- 箭头函数， this在函数声明时确定指向， 指向函数位置的this;
- 使用bind、apply、call手动绑定this对象；


### TS中的this

配置 `noImplicitThis`为true, 表示不允许this隐式的指向any；  implicit:暗示、含蓄的


在TS中， 允许在书写函数时， 手动的指向this指向； **在函数声明的时候第一个参数指定this的指向，该参数只用于约束this，并不是真正的参数， 也不会出现在编译接口中**

```ts
interface IUser {
	name: string,
	age: number,
	sayHello(this: IUser): void, // 第一个参数指定this的指向，不是真实的参数
}


const u: IUser = {
	name: 'sss',
	age: 9,
	sayHello(){
		console.log(this);
		
	}
}


class User {
	constructor (
		public name: string,
		public age: number,
	) {

	}

	sayHello(this: User) {

	}
}

const u = new User('hzg', 18);
const say = u.sayHello;

say(); // 这样执行时会报错。 不手动指定this的指向时， this指向undefined(class 中默认时严格模式)

```


# 装饰器

## 概述

> 面向对象的概念（java： 注解， c#： 特征）， decorator
> angular大量使用， react中也会用到
> 目前JS支持装饰器， `目前处于建议征集的第二阶段；` 还没成为标准；

### 解决问题

装饰器，能够带来额外的信息量， 可以达到分离关注点的目的；

- 关注点问题：在定义某个东西时，应该最清楚该东西的情况；  信息书写的位置问题；
- 重复代码的问题

上述两个问题产生的根源： 某些信息，在定义时能够附加的信息量有限

装饰器的作用： 为某些类、参数、属性、方法`提供元数据信息`（metadata)

> 元数据： 用来描述数据的数据

### 装饰器的本质

在js中， 装饰器是一个函数。（装饰器会参与运行的）

装饰器可以修饰：
- 类
- 成员（属性 + 方法）
- 参数

 **装饰器是可以复用的**

### 类装饰器 

类装饰器的本身是一个函数， 该函数接受一个参数， 表示类本身（构造函数本身）

使用装饰器``` @得到一个函数 ```

在TS中如何约束一个变量为类

- Function
- ```new (参数) => object ```

在TS中要使用装饰器， 需要开启 `experimentalDecorators: true` experimental: 实验性的 

装饰器函数的运行时间点： 在类定义后直接运行;

类装饰器可以具有的返回值：
- void: 仅运行函数
- 返回一个新的类： 会将新的类替换掉装饰目标

```ts
function test(target: new (...args: any[]) => object) {

}

@test
class A {
	constructor(public prop: string) {

	}
}


// 函数的执行 返回一个函数
function test1(str: string) {
	return function (target: new(...args: any[]) => object) {
		
	}
}

@test1('这是一个类')
class B {

}
```
**多个装饰器执行顺序： 从下往上倒着执行**


### 成员装饰器

- 属性
属性装饰器也是一个函数，该函数需要两个参数
1. 如果是静态属性， 则为类本身； 如果是实例属性，则为类的原型；
2. 固定为一个字符串， 表示属性名；

- 方法
方法装饰器也是一个函数，该函数需要三个参数
1. 如果是静态方法， 则为类本身； 如果是实例方法，则为类的原型；
2. 固定为一个字符串， 表示方法名；
3. 属性描述对象：属性描述符； Object.defineProperty的第三个参数

> 注意  如果代码输出目标版本小于ES5，属性描述符将会是 `undefined`。
```ts
// descriptor 属性描述对象的默认值
	{
		writable: true,
		enumerable: false,
		configurable: true,
		value: 方法本身
	}
```




# 声明文件

> 概述、编写、发布

### 概述

1. 什么是声明文件？
以 `.d.ts`结尾的文件

2. 声明文件有什么作用？

ts 读 js 代码时， 得不到类型声明 --> `为js代码提供类型声明；`

3. 声明文件的位置

- 放置到tsconfig.json配置中包含的目录中；  `includes` 包含的文件中
- 放置到node_modules/@types文件夹中
- 手动配置（权重最高） ```typeRoots: ['./types']``` 会覆盖上面两种配置；
- 与js代码所在目录相同，并且文件名也相同的文件。（最好）用ts代码书写的工程发布之后的格式。


### 编写声明文件

> 手动编写  自动生成

自动生成： 项目工程是用ts开发的，发布（编译）之后是js文件， 发布是js文件， 如果发布的文件， 需要其他开发者使用； 可以使用声明文件， 来描述发布结果中的类型；  配置```tsconfig.json```中的`declaration: true` 即可

手动编写：
1. 对已有库， 它是使用js书写而成， 并且更改该库的代码为ts成本较高，可以手动编写声明文件

2. 对一些第三方库， 它们使用js书写而成，并且这些第三方库没有提供声明文件， 可以手动编写声明文件

##### 全局声明

声明一些全局的对象、属性、变量

声明文件不参与运行； 只是声明类型；

```ts
declare // 声明

```

> namespace: 表示命名空间， 可以将其认为是一个对象， 命名空间中的内容， 必须通过```命名空间.成员名```访问


#### 模块声明


```ts

declare module 'lodash' {

}

// @types/lodash     yarn add -D @types/lodash

```

#### 三斜线指令

在一个声明文件中， 包含另一个声明文件

三根斜线 加空格
`/// <reference path="../../index.d.ts">`


## 发布

1. 当前工程是使用ts开发

编译完成后， 将编译结果所在文件夹直接发布到npm上即可

2. 为其他第三方库开发的声明文件

发布到@types/** 中


# 扩展类型

> 扩展类型： 类型别名、枚举、接口、类

# 枚举

枚举通常用于约束某个变量的取值范围。

字面量和联合类型配合使用， 也可以达到同样的目标；

### 字面量类型的问题

- 在类型约束位置， 会产生重复代码。 可以使用类型别名解决该问题。
- 逻辑含义和真实的值产生了混淆， 会导致当修改真实的值的时候，产生大量的修改。
- 字面量类型不会进入到编译结果；

如何定义一个枚举

```js
	enum 枚举名 {
		枚举字段1 = 值1,
		枚举字段2 = 值2
	}
```
``` js
	enum Gender {
		male = '男',
		female = '女'
	}

	let gender: Gender;
	gender = Gender.male;
```

枚举会参与编译， 会出现在编译结果中出现；编译结果中表现是一个对象； 字面量方式不会出现在编译结果中；

枚举的规则：

- 枚举的值可以是字符串和数字
- 数字枚举的值会自动自增；
- 被数字枚举约束的变量，可以直接赋值为数字；
- 4数字枚举的编译结果和字符串枚举有差异；

```js
 enmu Level {
	 level1 = 1,
	 level2,
	 level3
 }
```


```js
enmu Level {
	 level1 = 1,
	 level2,
	 level3
 }

// 数字枚举的编译结果 和 字符串编译结果的差异
{
	level1: 0,
	level2: 1,
	level3: 2,
	0: 'level1',
	1: 'level2',
	2: 'level3'
}

```

最佳实践

- 尽量不要在一个枚举中即出现字符串字段又出现数字字段；
- 使用枚举时，尽量使用枚举字段的名称， 而不是使用真实的值；

### 扩展的知识： 位枚举（枚举的位运算）

只针对数字枚举

位运算： 两个数字换算成二进制后进行的运算；



# 模块化

> 前端模块化的标准： ES6、commonjs、amd、umd、system、esnext

### TS中如何书写模块化语句

> TS 中导入和导出模块， `统一使用ES6的模块化` 避免出错; 
 
普通导出 可以智能提示， 快速修复； 默认导出（ `export default`)， 不能智能提示； 因为可以修改导出的名字；

不要加后缀名；编译结果中没有`.ts`文件

### 编译结果中的模块化

dist 文件夹   编译命令 tsc; `tsc --watch` 监听文件变化，文件变化后会重新编译；

去掉编译结果中的注释 tsconfig.json中 加`"removeComments: true"`

|		配置名称		 |		含义		|
| :-------------------: | :---------------:|
| module				| 设置编译结果中使用的模块化标准 |
| moduleResolution		| 设置解析模块的模式 |
| noImplicitUseStrict	| 编译结果中不包括"use strict" |
| removeComments 		| 编译结果中移除注释 |
| noEmitOnError			| 错误时不生成编译结果 |
| esModuleInterop 		| 启用es模块化交互非es模块导出 |

TS中的模块化在编译结果中：
- 如果编译结果的模块化标准是ES6: 没有区别；
- 如果编译结果的模块化标准是commonJs： 导出的声明会变成exports的属性。 默认的导出会变成exports的default属性；导入时会把对象拿到； 通过对象属性的方式执行；

### 解决默认导入的错误

```js

import fs from 'fs';// 会报错； 因为fs模块采用的是 module.exports = {}; 方式导出的； 不是采用es6默认导出方式；

// 解决方式

import * as fs from 'fs';
import { readFileSync } from 'fs';

// 上面两种方式可以解决默认导入的错误；

// 或者编译选项中增加配置； 直接导入就不会出错
// esmoduleInterop : true 

```


# 如何在TS中书写commonjs模块化代码

不太建议；建议使用es6模块化   

```js
// 老式方式 没有类型推导  module.export = xxx;  const xxx = require('xxx');
// 导出  export = XXX
export = {

}

// 导入 import xxx = require('xxx')

import myModule = require('./myModule')


```


# 模块解析

模块解析： 应该从什么位置寻找模块
TS中， 有两种模块解析策略

- classic: 经典
- node: node解析策略（唯一变化， 将js替换为ts);

> 增加模块解析策略配置： `moduleResolution: 'node'` 强行设置为node解析策略